/* Generated by Nim Compiler v2.2.2 */
/* Compiled for: Linux, wasm32, clang */
/* Command for C compiler:
   emcc -c -w -ferror-limit=3 -pthread -O3   -I/home/gregis/.choosenim/toolchains/nim-2.2.2/lib -I/home/gregis/Projects/OneLastBeat/src -o /home/gregis/Projects/OneLastBeat/tmp/@m..@s..@s..@s.nimble@spkgs2@ssdl2_nim-2.0.14.3-dd020f93fcf762e28d3d1462a7bba0c91a5a36dd@ssdl2_nim@ssdl.nim.c.o /home/gregis/Projects/OneLastBeat/tmp/@m..@s..@s..@s.nimble@spkgs2@ssdl2_nim-2.0.14.3-dd020f93fcf762e28d3d1462a7bba0c91a5a36dd@ssdl2_nim@ssdl.nim.c */
#define NIM_INTBITS 32

#include "nimbase.h"
#include <string.h>
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef far
#undef powerpc
#undef unix
typedef struct NimStrPayload NimStrPayload;
typedef struct NimStringV2 NimStringV2;
struct NimStrPayload {
	NI cap;
	NIM_CHAR data[SEQ_DECL_SIZE];
};
struct NimStringV2 {
	NI len;
	NimStrPayload* p;
};
N_LIB_PRIVATE N_NOCONV(void, deallocShared)(void* p_p0);
N_LIB_PRIVATE N_NIMCALL(NimStringV2, nimCharToStr)(NIM_CHAR x_p0);
static N_INLINE(void, appendString)(NimStringV2* dest_p0, NimStringV2 src_p1);
static N_INLINE(void, copyMem__system_u1731)(void* dest_p0, void* source_p1, NI size_p2);
static N_INLINE(void, nimCopyMem)(void* dest_p0, void* source_p1, NI size_p2);
N_LIB_PRIVATE N_NIMCALL(void, prepareAdd)(NimStringV2* s_p0, NI addLen_p1);
static N_INLINE(NIM_BOOL*, nimErrorFlag)(void);
static const struct {
  NI cap; NIM_CHAR data[0+1];
} TM__T8sPUeYymAg4VnmycaqyjQ_2 = { 0 | NIM_STRLIT_FLAG, "" };
static const NimStringV2 TM__T8sPUeYymAg4VnmycaqyjQ_3 = {0, (NimStrPayload*)&TM__T8sPUeYymAg4VnmycaqyjQ_2};
extern NIM_THREADVAR NIM_BOOL nimInErrorMode__system_u4433;
N_LIB_PRIVATE N_NIMCALL(NI, toInt__pkgZsdl295nimZsdl_u581)(NU8 x_p0) {
	NI result;
	result = ((NI) (x_p0));
	return result;
}
static N_INLINE(void, nimCopyMem)(void* dest_p0, void* source_p1, NI size_p2) {
	void* T1_;
	T1_ = (void*)0;
	T1_ = memcpy(dest_p0, source_p1, ((size_t) (size_p2)));
}
static N_INLINE(void, copyMem__system_u1731)(void* dest_p0, void* source_p1, NI size_p2) {
	nimCopyMem(dest_p0, source_p1, size_p2);
}
static N_INLINE(void, appendString)(NimStringV2* dest_p0, NimStringV2 src_p1) {
	{
		if (!(((NI)0) < src_p1.len)) goto LA3_;
		copyMem__system_u1731(((void*) ((&(*(*dest_p0).p).data[(*dest_p0).len]))), ((void*) ((&(*src_p1.p).data[((NI)0)]))), ((NI)(src_p1.len + ((NI)1))));
		(*dest_p0).len += src_p1.len;
	}
LA3_: ;
}
static N_INLINE(NIM_BOOL*, nimErrorFlag)(void) {
	NIM_BOOL* result;
	result = (&nimInErrorMode__system_u4433);
	return result;
}
N_LIB_PRIVATE N_NIMCALL(NimStringV2, charArrayToString__pkgZsdl295nimZsdl_u3847)(NIM_CHAR* a_p0, NI a_p0Len_0) {
	NimStringV2 result;
NIM_BOOL* nimErr_;
{nimErr_ = nimErrorFlag();
	result = TM__T8sPUeYymAg4VnmycaqyjQ_3;
	{
		NIM_CHAR c;
		NI i;
		c = (NIM_CHAR)0;
		i = ((NI)0);
		{
			while (1) {
				NimStringV2 colontmpD_;
				if (!(i < a_p0Len_0)) goto LA3;
				colontmpD_.len = 0; colontmpD_.p = NIM_NIL;
				c = a_p0[i];
				{
					if (!((NU8)(c) == (NU8)(0))) goto LA7_;
					if (colontmpD_.p && !(colontmpD_.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(colontmpD_.p);
}
					goto LA1;
				}
LA7_: ;
				colontmpD_ = nimCharToStr(c);
				prepareAdd((&result), colontmpD_.len + 0);
appendString((&result), colontmpD_);
				i += ((NI)1);
				{
					LA4_:;
				}
				{
					if (colontmpD_.p && !(colontmpD_.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(colontmpD_.p);
}
				}
				if (NIM_UNLIKELY(*nimErr_)) goto BeforeRet_;
			} LA3: ;
		}
	} LA1: ;
	}BeforeRet_: ;
	return result;
}
